import{Node}from"./node.js";class BinaryTree{constructor(data,left=null,right=null){this.data=data,this.left=left,this.right=right}printPreOrder=()=>{this.preOrderWalk(this)};printInOrder=()=>{this.inOrderWalk(this)};printPostOrder=()=>{this.postOrderWalk(this)};printReverseOrder=()=>{this.reverseOrderWalk(this)};preOrderWalk=root=>{null!==root&&(console.log(root.data),this.preOrderWalk(root.left),this.preOrderWalk(root.right))};inOrderWalk=root=>{null!==root&&(this.inOrderWalk(root.left),console.log(root.data),this.inOrderWalk(root.right))};postOrderWalk=root=>{null!==root&&(this.postOrderWalk(root.left),this.postOrderWalk(root.right),console.log(root.data))};reverseOrderWalk=root=>{null!==root&&(this.inOrderWalk(root.right),console.log(root.data),this.inOrderWalk(root.left))}}class BinarySearchTree{constructor(arrList){let sortedList=arrList.sort((a,b)=>a-b);this.root=BinarySearchTree.sortedArrayToBST(sortedList)}static sortedArrayToBST=array=>0===array.length?null:BinarySearchTree.sortedArrayToBSTHelper(array,0,array.length-1);static sortedArrayToBSTHelper=(arr,start,end)=>{if(start===end)return new BinaryTree(arr[start],null,null);let mid=Math.floor((start+end)/2),left=null;mid-1>=start&&(left=BinarySearchTree.sortedArrayToBSTHelper(arr,start,mid-1));let right=null,root;return mid+1<=end&&(right=BinarySearchTree.sortedArrayToBSTHelper(arr,mid+1,end)),new BinaryTree(arr[mid],left,right)};keyExist=key=>{let iterator=this.root;for(;null!==iterator;){if(iterator.data===key)return!0;iterator=iterator.data>key?iterator.left:iterator.right}return!1};search=key=>{let iterator=this.root;for(;null!==iterator;){if(iterator.data===key)return iterator;iterator=iterator.data>key?iterator.left:iterator.right}return null};insert=value=>{if(null===this.root)return null;let iterator=this.root,node=new BinaryTree(value,null,null);for(;null!==iterator;)iterator.data>value&&null===iterator.left?iterator.left=node:iterator.data<value&&null===iterator.right&&(iterator.right=node),iterator=iterator.data>value?iterator.left:iterator.right;return this.root};transplant=(parent,node,target)=>{null===parent?this.root=target:parent.left===node?parent.left=target:parent.right=target};deleteNode=key=>{if(null===this.root)return null;let node=this.search(key);if(!this.keyExist(key))return this.root;let parent=this.findParent(node);if(null===node.left)this.transplant(parent,node,node.right);else if(null===node.right)this.transplant(parent,node,node.left);else{let successor=this.findSuccessor(node),successorParent=this.findParent(successor);successor!==node.right&&(this.transplant(successorParent,successor,successor.right),successor.right=node.right),this.transplant(parent,node,successor),successor.left=node.left}};findParent=node=>{let iterator=this.root,parent=this.root;for(;null!==iterator;)parent=iterator,iterator=iterator.data>node.data?iterator.left:iterator.right;return parent};findSuccessor=node=>{let targetNode=node;if(null===targetNode)return null;if(null!==targetNode.right)return this.minimumNode(targetNode.right);let successor=null,iterator=this.root;for(;null!==iterator;){if(targetNode.data===iterator.data)return successor;targetNode.data<iterator.data&&(null===successor||iterator.data<successor.data)&&(successor=iterator.left),iterator=targetNode.data<iterator.data?iterator.left:iterator.right}return successor};minimumNode=node=>{let iterator=node;for(;null!==iterator&&null!==iterator.left;)iterator=iterator.left;return iterator};printSorted=key=>{switch(key){case"pre":return this.root.printPreOrder();case"in":return this.root.printInOrder();case"post":return this.root.printPostOrder();case"reverse":return this.root.printReverseOrder();default:return null}}}class HeapLibrary{static left=i=>2*i+1;static right=i=>2*i+2;static parent=i=>Math.floor((i-1)/2);static buildMaxHeap=arr=>{let mid;for(let i=HeapLibrary.parent(arr.length-1);i>=0;i--)HeapLibrary.maxHeapify(arr,arr.length-1,i);return arr};static maxHeapify=(arr,heapEnd,i)=>{let l=HeapLibrary.left(i),r=HeapLibrary.right(i),biggest=i;if(l<=heapEnd&&arr[l]>arr[biggest]&&(biggest=l),r<=heapEnd&&arr[r]>arr[biggest]&&(biggest=r),biggest!==i)return[arr[i],arr[biggest]]=[arr[biggest],arr[i]],HeapLibrary.maxHeapify(arr,heapEnd,biggest)};static heapSort=arr=>{Heap.buildMaxHeap(arr);let heapEnd=arr.length-1;for(;heapEnd>0;)[arr[heapEnd],arr[0]]=[arr[0],arr[heapEnd]],heapEnd--,Heap.maxHeapify(arr,heapEnd,0);return arr}}class PriorityQueue{constructor(arr){this.maxHeap=[...arr],HeapLibrary.buildMaxHeap(this.maxHeap)}top=()=>this.maxHeap[0];pop=()=>{let poped=this.maxHeap[0];return this.maxHeap[0]=this.maxHeap[this.maxHeap.length-1],this.maxHeap.pop(),HeapLibrary.maxHeapify(this.maxHeap,this.maxHeap.length-1,0),poped};insert=node=>{this.maxHeap.push(node);let len=this.maxHeap.length-1,parent=HeapLibrary.parent(len);for(;parent>=0&&this.maxHeap[parent]<node;)[this.maxHeap[len],this.maxHeap[parent]]=[this.maxHeap[parent],this.maxHeap[len]],len=parent,parent=HeapLibrary.parent(len)}}class dNode extends Node{constructor(data){super(data),this.prev=null}}class DoublyLinkedList{constructor(arr){if(arr.length<=0)return this.head=new dNode(null),void(this.tail=this.head);this.head=new dNode(arr[0]);let currNode=this.head;for(let i=1;i<arr.length;i++)currNode.next=new dNode(arr[i]),currNode.next.prev=currNode,currNode=currNode.next;this.tail=currNode}at=index=>{let iterator=this.head;for(let i=0;i<index;i++)if(iterator=iterator.next,null===iterator)return null;return iterator};popFront=()=>{let temp=this.head;return this.head=this.head.next,this.head.prev=null,temp.data};pop=()=>{let temp=this.tail;return this.tail=this.tail.prev,this.tail.next=null,temp.data};append=data=>{let newNode=new dNode(data);this.tail.next=newNode,newNode.next=null,newNode.prev=this.tail,this.tail=newNode};addNextNode=(data,index)=>{let newNode=new dNode(data),preNode=this.at(index),temp=preNode.next;preNode.next=newNode,newNode.next=temp,newNode.prev=preNode,preNode===this.tail?this.tail=newNode:temp.prev=newNode};deleteNode=index=>{let target=this.at(index);return target?target===this.tail?this.pop():target===this.head?this.popFront():(target.prev.next=target.next,void(target.next.prev=target.prev)):null};reverse=()=>{let reverse=this.tail,iterator=this.tail.prev,currNode=reverse;for(;null!==iterator;)currNode.next=iterator,iterator=iterator.prev,null!==iterator&&(iterator.next=null),currNode.next.prev=currNode,currNode=currNode.next;this.tail=currNode,this.head=reverse,this.head.prev=null};printList=()=>{let iterator=this.head,results="";for(;null!==iterator;)results+=iterator.data+" ",iterator=iterator.next;console.log(results)}}class sNode extends Node{addNextNode(newNode){let temp=this.head;this.next=newNode,newNode.next=temp}}class SinglyLinkedList{constructor(arr){this.head=arr.length>0?new sNode(arr[0]):new sNode(null);let currNode=this.head;for(let i=1;i<arr.length;i++)currNode.next=new sNode(arr[i]),currNode=currNode.next}at=index=>{let iterator=this.head;for(let i=0;i<index;i++)if(iterator=iterator.next,null==iterator)return null;return iterator};preAppend=data=>{let newNode=new sNode(data);newNode.next=this.head,this.head=newNode};append=data=>{let newNode=new sNode(data),iterator=this.head;for(;null!==iterator.next;)iterator=iterator.next;iterator.next=newNode};popFront=()=>{let temp=this.head;return this.head=this.head.next,temp.data};delete=index=>{if(0===index)return this.popFront();let iterator=this.head;for(let i=0;i<index-1;i++){if(null===iterator.next)return null;iterator=iterator.next}iterator.next=iterator.next.next};reverse=()=>{if(null===this.head||null===this.head.next)return;let reverse=this.head;for(this.head=this.head.next,reverse.next=null;null!==this.head;){let temp=this.head;this.head=this.head.next,temp.next=reverse,reverse=temp}this.head=reverse};printList=()=>{let iterator=this.head,results="";for(;null!==iterator;)results+=iterator.data+" ",iterator=iterator.next;console.log(results)}}class QueueNode extends Node{constructor(data){super(data),this.prev=null}}class Deque{constructor(){this.head=null,this.tail=null}peekFront=()=>null===this.head?null:this.head.data;peekBack=()=>null===this.tail?null:this.tail.data;enqueueFront=data=>{let newNode=new QueueNode(data);return null===this.head?(this.head=newNode,void(this.tail=this.head)):(this.head.prev=newNode,newNode.next=this.head,void(this.head=newNode))};enqueueBack=data=>{let newNode=new QueueNode(data);return null===this.head?(this.head=newNode,void(this.tail=this.head)):(this.tail.next=newNode,newNode.prev=this.tail,void(this.tail=newNode))};dequeueFront=()=>{if(null===this.head)return null;let temp=this.head;return this.head=this.head.next,null===this.head?this.head.prev=null:this.tail=null,temp};dequeueBack=()=>{if(null===this.head)return null;let temp=this.tail;return this.tail=this.tail.prev,null!==this.tail?this.tail.next=null:this.head=null,temp};printDeque=()=>{if(null===this.head)return null;let iterator=this.head,results="";for(;iterator!==this.tail;)results+=iterator.data+" ",iterator=iterator.next;return results+=iterator.data,results}}class Stack{constructor(){this.head=null}push=data=>{let temp=this.head;this.head=new Node(data),this.head.next=temp};peek=()=>null===this.head?null:this.head.data;pop=()=>{if(null===this.head)return null;let temp=this.head;return this.head=this.head.next,temp.data}}module.exports={BinarySearchTree:BinarySearchTree,HeapLibrary:HeapLibrary,PriorityQueue:PriorityQueue,DoublyLinkedList:DoublyLinkedList,SinglyLinkedList:SinglyLinkedList,Deque:Deque,Stack:Stack};